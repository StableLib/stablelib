// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.

/**
 * Package chacha-drbg implements ChaCha-based digital random byte generator.
 */

import { defaultRandomSource, RandomSource } from "@stablelib/random";
import { streamXOR, stream } from "@stablelib/chacha";
import { wipe } from "@stablelib/wipe";

// Maximum number of bytes to generate before reseeding.
const RESEED_MAX_BYTES = 1024 * 1024; // 1 MiB

/**
 * ChaCha DRBG.
 */
export class ChaChaDRBG implements RandomSource {
    isAvailable = false;
    isInstantiated = false;

    // Secret key containing entropy.
    private _key = new Uint8Array(32);

    // Number of bytes generated since last reseed.
    private _bytesGenerated = 0;

    // Nonce to use when reseeding (incremented after each reseed)
    private _reseedNonce = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0]);

    // Nonce to use when generating bytes (incremented after each generation
    // and reset back after reseeding). The first byte is different from
    // reseedNonce's first byte and is never incremented to ensure the two
    // nonce are always different.
    private _extractNonce = new Uint8Array([2, 0, 0, 0, 0, 0, 0, 0]);

    // Nonce to use when rekeying.
    private _rekeyNonce = new Uint8Array([3, 0, 0, 0, 0, 0, 0, 0]);

    constructor(private _entropySource: RandomSource = defaultRandomSource) {
        this.isAvailable = this._entropySource.isAvailable;
    }

    private _instantiate() {
        if (!this._entropySource.isAvailable) {
            throw new Error("ChaChaDRBG: entropy source is not available");
        }
        this._reseed();
        this.isInstantiated = true;
    }

    private _reseed() {
        // Get random bytes from system.
        const tmp = this._entropySource.randomBytes(32);

        // Encrypt these bytes with current key.
        streamXOR(this._key, this._reseedNonce, tmp, tmp);

        // Increment reseed nonce, so that next reseed with the same
        // key and bytes will never generate the same new key.
        incrementNonce(this._reseedNonce);

        // Set the result as new key.
        this._key.set(tmp);

        // Cleanup.
        wipe(tmp);

        // Reset extractNonce and rekeyNonce so that they start counting from zero.
        for (let i = 7; i >= 1; i--) {
            this._extractNonce[i] = 0;
            this._rekeyNonce[i] = 0;
        }
        // Reset the number of generated bytes.
        this._bytesGenerated = 0;
    }

    // Overwrite PRNG key with output of ChaCha20 stream generated with current
    // key and rekeyNonce, making it infeasible to guess bytes generated before
    // rekeying if PRNG state is leaked.
    rekey() {
        // Generate stream to temporary space.
        const tmp = new Uint8Array(32);

        stream(this._key, this._rekeyNonce, tmp);

        // Set result as new key.
        this._key.set(tmp);

        // Cleanup.
        wipe(tmp);

        // Increment rekeying nonce so that next rekeys with the same
        // key won't produce the same new key. Chances of this happening
        // are almost non-existent, but why not.
        incrementNonce(this._rekeyNonce);
    }

    private _generate(length: number): Uint8Array {
        // Reseed if we generated or will generate more bytes
        // than allowed without reseeding.
        if (this._bytesGenerated + length > RESEED_MAX_BYTES) {
            this._reseed();
        }

        let out = new Uint8Array(length);

        // Generate stream.
        stream(this._key, this._extractNonce, out);

        // Increment extract nonce.
        incrementNonce(this._extractNonce);

        // Add the number of generated bytes.
        this._bytesGenerated += out.length;

        // Rekey for forward security.
        this.rekey();

        return out;
    }

    randomBytes(length: number): Uint8Array {
        if (!this.isInstantiated) {
            this._instantiate();
        }
        return this._generate(length);
    }
}

// Increments the last 7 bytes of nonce as if it was a 56-bit number.
function incrementNonce(nonce: Uint8Array) {
    for (let i = 7; i >= 1; i--) {
        nonce[i] = nonce[i] + 1 & 0xff;
        if (nonce[i] !== 0) {
            break;
        }
    }
}
